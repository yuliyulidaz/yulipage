<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>소설 내지 생성기 (A6 문고판)</title>
    
    <!-- 1. Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Noto Serif KR (본문 명조) -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@200;300;400;500&display=swap" rel="stylesheet">
    <!-- Gowun Batang (고운 바탕) -->
    <link href="https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@400;700&display=swap" rel="stylesheet">
    <!-- Nanum Myeongjo (나눔 명조) -->
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&display=swap" rel="stylesheet">
    <!-- Hahmlet (함렛) -->
    <link href="https://fonts.googleapis.com/css2?family=Hahmlet:wght@100;200;300;400;500;600&display=swap" rel="stylesheet">
    <!-- Nanum Pen Script (나눔손글씨 펜 - for Signature) -->
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Pen+Script&display=swap" rel="stylesheet">
    
    <!-- 2. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 3. Libraries (React, ReactDOM, Babel, html-to-image) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html-to-image/1.11.11/html-to-image.js"></script>

    <style>
        /* 폰트 강제 적용 */
        * {
            -webkit-font-smoothing: antialiased;
        }

        body {
            font-family: 'Noto Serif KR', serif;
            background: #f0f2f5;
            color: #1a1a1a;
            overscroll-behavior: none; /* 스크롤 튕김 방지 */
        }

        /* 하이라이트 스타일 - 그룹 ID 속성 활용 */
        .highlight {
            display: inline;
            background: rgba(255, 235, 59, 0.4);
            padding: 0;
            margin: 0;
            /* line-height: normal; -> inherit로 변경하여 자간 뭉개짐 방지 */
            line-height: inherit;
            letter-spacing: inherit;
            vertical-align: baseline;
            border: none;
            outline: none;
            cursor: pointer;
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
        }
        
        .highlight-yellow { background: rgba(255, 235, 59, 0.4); }
        .highlight-pink { background: rgba(255, 182, 193, 0.4); }
        .highlight-mint { background: rgba(178, 255, 222, 0.4); }
        .highlight-blue { background: rgba(173, 216, 230, 0.4); }

        /* 글자 색 스타일 */
        .colored-text {
            display: inline;
            cursor: pointer;
            /* 자간 뭉개짐 방지 */
            line-height: inherit;
            letter-spacing: inherit;
            box-decoration-break: clone;
            -webkit-box-decoration-break: clone;
        }
        .text-crimson { color: #be123c; } 
        .text-navy { color: #1e3a8a; }    
        .text-forest { color: #15803d; }
        .text-purple { color: #6b21a8; } /* 진한 보라 */
        .text-brown { color: #78350f; }  /* 갈색 */
        .text-teal { color: #0f766e; }   /* 청록색 */
        .text-gray { color: #9ca3af; }    
        
        /* 글자 색 선택 버튼 (배경색) */
        .bg-text-crimson { background-color: #be123c; }
        .bg-text-navy { background-color: #1e3a8a; }
        .bg-text-forest { background-color: #15803d; }
        .bg-text-purple { background-color: #6b21a8; }
        .bg-text-brown { background-color: #78350f; }
        .bg-text-teal { background-color: #0f766e; }
        .bg-text-gray { background-color: #9ca3af; }

        /* 화면용 스타일 - A6 비율 (105:148) */
        .page-container {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            background: white;
            margin: 0 auto;
            width: 420px;  
            min-width: 420px; 
            flex-shrink: 0;
            height: 600px; 
            padding: 60px 60px 50px 60px; 
            position: relative;
            display: flex;
            flex-direction: column;
            transform-origin: top center;
            transition: background-color 0.3s, color 0.3s;
        }
        
        /* 테마별 스타일 - 선택자 공백 제거 (중요) */
        .theme-white.page-container { background: #ffffff; color: #1a1a1a; }
        .theme-cream.page-container { background: #fdfbf7; color: #2c241b; }
        .theme-kraft.page-container { background: #e6dac3; color: #3e2723; background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E"); }
        .theme-dark.page-container { background: #1a1a1a; color: #e5e5e5; }

        .page-content {
            height: 460px; 
            overflow: hidden;
            font-size: 12px;
            line-height: 1.8 !important;
            text-align: justify;
            letter-spacing: -0.02em;
            word-break: break-all;
            overflow-wrap: anywhere;
            font-weight: 300;
            cursor: text;
        }

        /* 문단 스타일 */
        .page-content p {
            margin-bottom: 0;
            padding: 0;
            text-indent: 1em;
            line-height: 1.8 !important;
        }

        /* 이어진 문단 */
        .page-content p.continued {
            text-indent: 0 !important;
        }
        
        .page-footer-area {
            height: 30px;
            margin-top: auto;
            display: flex;
            align-items: flex-end;
            padding-bottom: 0px;
        }

        /* 입력 화면 */
        .input-area {
            max-width: 900px;
            margin: 40px auto;
            background: white;
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.05);
        }

        /* 측정용 숨겨진 박스 - 항상 460px 높이 기준 */
        .hidden-measure {
            position: absolute;
            visibility: hidden;
            top: -9999px;
            left: -9999px;
            width: 300px; /* page-content width (420 - 120) */
            font-size: 12px;
            line-height: 1.8 !important;
            text-align: justify;
            letter-spacing: -0.02em;
            word-break: break-all;
            overflow-wrap: anywhere;
            font-weight: 300;
        }
        
        .hidden-measure p {
            margin-bottom: 0;
            line-height: 1.8 !important;
        }

        /* 색상/테마 선택 버튼 */
        .circle-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }
        .circle-btn:hover { transform: scale(1.1); }
        .circle-btn.active { border-color: #333; transform: scale(1.1); }
        
        /* 테마 버튼 색상 */
        .theme-btn-white { background: #ffffff; border: 1px solid #ddd; }
        .theme-btn-cream { background: #fdfbf7; border: 1px solid #e6e0d4; }
        .theme-btn-kraft { background: #e6dac3; border: 1px solid #cbbba0; }
        .theme-btn-dark { background: #1a1a1a; border: 1px solid #444; }

        /* 유틸리티 */
        .btn {
            transition: all 0.2s;
        }
        .btn:active {
            transform: scale(0.98);
        }
        
        /* 플레이스홀더 스타일 */
        .custom-placeholder {
            position: absolute;
            top: 24px; 
            left: 24px;
            right: 24px;
            bottom: 24px;
            pointer-events: none;
            color: #94a3b8;
            font-size: 14px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        /* 모바일 반응형 */
        @media (max-width: 450px) {
            #bookViewerWrapper {
                transform: scale(0.85);
                transform-origin: top center;
                height: 520px; 
            }
        }

        /* -----------------------------------------------
           MOCKUP VIEWER STYLES
           ----------------------------------------------- */
        .mockup-bg {
            background-color: #f2efe9;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 40px 20px;
            overflow: hidden;
            min-height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
        }

        .book-container {
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: center center;
            transform: scale(0.9);
            padding: 60px; /* Padding for shadow */
        }
        
        @media (max-width: 1000px) {
            .book-container {
                transform: scale(0.6);
            }
        }
        @media (max-width: 600px) {
             .book-container {
                transform: scale(0.36);
                flex-direction: row; 
            }
        }

        .book-shadow-wrapper {
             display: flex;
             position: relative;
             /* Ensure no other shadows interfere */
             box-shadow: none !important;
        }
        
        /* 
           [New Strategy] CSS Gradient Shadow
           Replaces problematic SVG and Box-Shadows with a pure CSS Gradient.
           This renders perfectly on all devices as it is just color data.
        */
        .book-real-shadow {
            position: absolute;
            z-index: -1;
            /* Make it wider than the book */
            left: 2%;
            width: 96%;
            /* Position it at the bottom */
            bottom: -30px;
            height: 60px;
            /* The Magic: Radial gradient mimicking a soft shadow */
            background: radial-gradient(50% 50% at 50% 50%, rgba(0,0,0,0.25) 0%, rgba(0,0,0,0.08) 50%, transparent 100%);
            /* Slight blur for extra softness, usually safe on modern iOS */
            /* If this fails, the gradient itself is still a good fallback */
            filter: blur(10px);
            opacity: 0.8;
            transform: scaleX(1.1); /* Stretch it a bit horizontally */
        }

        .book-spine-shadow {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 80px; 
            margin-left: -40px;
            pointer-events: none;
            background: linear-gradient(to right, 
                rgba(0,0,0,0) 0%, 
                rgba(0,0,0,0.02) 20%, 
                rgba(0,0,0,0.1) 40%, 
                rgba(0,0,0,0.15) 50%, 
                rgba(0,0,0,0.1) 60%, 
                rgba(0,0,0,0.02) 80%, 
                rgba(0,0,0,0) 100%);
            mix-blend-mode: multiply;
            z-index: 20;
        }

        .curve-left {
            position: absolute;
            inset: 0;
            background: linear-gradient(to right, 
                rgba(255,255,255,0) 80%, 
                rgba(0,0,0,0.06) 100%);
            pointer-events: none;
            z-index: 10;
        }

        .curve-right {
            position: absolute;
            inset: 0;
            background: linear-gradient(to right, 
                rgba(255,255,255,0.2) 0%, 
                rgba(255,255,255,0) 15%,
                rgba(0,0,0,0) 100%);
            pointer-events: none;
            z-index: 10;
        }

        .paper-stack-left {
            position: absolute;
            left: 2px;
            top: 4px;
            bottom: 4px;
            width: 4px;
            border-left: 1px solid rgba(0,0,0,0.1);
            background: linear-gradient(to right, #f5f5f5, #fff);
            z-index: -1;
            transform: translateX(-100%);
        }
        .paper-stack-right {
            position: absolute;
            right: 2px;
            top: 4px;
            bottom: 4px;
            width: 4px;
            border-right: 1px solid rgba(0,0,0,0.1);
            background: linear-gradient(to left, #f5f5f5, #fff);
            z-index: -1;
            transform: translateX(100%);
        }

        .mockup-page {
            width: 420px;
            height: 600px;
            position: relative;
            background-color: white; 
            overflow: hidden;
        }

        .mockup-endpaper {
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.08'/%3E%3C/svg%3E");
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 50px;
            box-shadow: inset -5px 0 10px rgba(0,0,0,0.2); 
        }
    </style>

</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
        const { useState, useRef, useEffect, useCallback } = React;

        // ----------------------------------------------------------------------
        // 1. Utils & Helpers
        // ----------------------------------------------------------------------

        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }
        
        function isIPad() {
            return /iPad/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }
        
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }

        async function ensureFontsLoaded() {
            try {
                await document.fonts.ready;
            } catch (e) {
                console.warn('폰트 API 확인 실패', e);
            }
        }

        const fontCache = new Map();
        
        const FONT_MAP = {
            'noto': { name: '본문 명조', family: "'Noto Serif KR', serif", url: 'https://fonts.googleapis.com/css2?family=Noto+Serif+KR:wght@200;300;400;500&display=swap' },
            'nanum': { name: '나눔 명조', family: "'Nanum Myeongjo', serif", url: 'https://fonts.googleapis.com/css2?family=Nanum+Myeongjo:wght@400;700;800&display=swap' },
            'hahmlet': { name: '함렛', family: "'Hahmlet', serif", url: 'https://fonts.googleapis.com/css2?family=Hahmlet:wght@100;200;300;400;500;600&display=swap' },
            'gowun': { name: '고운 바탕', family: "'Gowun Batang', serif", url: 'https://fonts.googleapis.com/css2?family=Gowun+Batang:wght@400;700&display=swap' }
        };

        async function prepareFontEmbedCSS(activeFontKey) {
            if (fontCache.has(activeFontKey)) return fontCache.get(activeFontKey);
            
            try {
                const fontInfo = FONT_MAP[activeFontKey];
                if (!fontInfo) return null;

                const cssRes = await fetch(fontInfo.url);
                let cssText = await cssRes.text();

                const urlRegex = /url\(([^)]+)\)/g;
                let match;
                const replacements = [];

                while ((match = urlRegex.exec(cssText)) !== null) {
                    const fullUrl = match[1].replace(/['"]/g, ''); 
                    replacements.push({ original: match[0], url: fullUrl });
                }

                await Promise.all(replacements.map(async (item) => {
                    try {
                        const fontRes = await fetch(item.url);
                        const fontBlob = await fontRes.blob();
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                cssText = cssText.replace(item.url, reader.result);
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(fontBlob);
                        });
                    } catch (e) {
                        console.warn('개별 폰트 로드 실패:', item.url, e);
                    }
                }));

                fontCache.set(activeFontKey, cssText);
                return cssText;
            } catch (e) {
                console.error('[폰트] 임베드 생성 실패:', e);
                return null;
            }
        }

        function useDebounce(value, delay) {
            const [debouncedValue, setDebouncedValue] = useState(value);
            useEffect(() => {
                const handler = setTimeout(() => {
                    setDebouncedValue(value);
                }, delay);
                return () => clearTimeout(handler);
            }, [value, delay]);
            return debouncedValue;
        }

        const PAGE_CONTENT_HEIGHT = 460;
        const BOTTOM_BUFFER_P1 = 15;

        function App() {
            // -- State --
            const [step, setStep] = useState('input');
            const [textInput, setTextInput] = useState('');
            const [metadata, setMetadata] = useState({
                title: '',
                author: '',
                producer: ''
            });
            
            const [activeTheme, setActiveTheme] = useState('white'); 
            const [activeFont, setActiveFont] = useState('noto'); 
            
            const [activeTab, setActiveTab] = useState(null);
            const [toolMode, setToolMode] = useState('highlight');
            
            const [pages, setPages] = useState([]);
            const [currentPageIdx, setCurrentPageIdx] = useState(0);
            const [pageHighlights, setPageHighlights] = useState({});
            
            const [currentHighlightColor, setCurrentHighlightColor] = useState('highlight-yellow');
            const [currentTextColor, setCurrentTextColor] = useState('text-crimson');
            
            const [isGenerating, setIsGenerating] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [loadingProgress, setLoadingProgress] = useState(0);
            
            const debouncedText = useDebounce(textInput, 500);
            const [estimatedPages, setEstimatedPages] = useState(0);

            const [mockupSpreads, setMockupSpreads] = useState([]);
            const [currentMockupIdx, setCurrentMockupIdx] = useState(0);
            
            const [infoText, setInfoText] = useState('');
            const [isEditingInfo, setIsEditingInfo] = useState(false);

            const measureContainerRef = useRef(null);
            const viewerRef = useRef(null);
            const contentRef = useRef(null);

            const handleInfoChange = (e) => {
                const val = e.target.value;
                const lines = val.split('\n');
                if (lines.length > 6) return;
                setInfoText(val);
            };

            const handleInfoFocus = () => {
                if (isMobile()) setIsEditingInfo(true);
            };

            const handleInfoBlur = () => {
                setIsEditingInfo(false);
            };

            const calculatePages = (text, fontKey) => {
                const measureBox = measureContainerRef.current;
                if (!measureBox) return [];

                measureBox.style.fontFamily = FONT_MAP[fontKey].family;
                
                const rawParagraphs = text.split('\n');
                let currentParagraphs = [];
                let pageNum = 1;
                let resultPages = [];
                
                let queue = rawParagraphs.map(text => {
                    const trimmed = text.trim();
                    if (trimmed === '***') {
                        return { 
                            text: '*\u00A0\u00A0\u00A0\u00A0\u00A0*\u00A0\u00A0\u00A0\u00A0\u00A0*', 
                            isContinued: false, 
                            isSceneBreak: true 
                        };
                    }
                    return { text: text, isContinued: false, isSceneBreak: false };
                });

                measureBox.innerHTML = ''; 
                
                if (metadata.title && pageNum === 1) {
                    const titlePlaceholder = document.createElement('div');
                    titlePlaceholder.style.height = "200px";
                    titlePlaceholder.style.width = "100%";
                    titlePlaceholder.style.marginBottom = "0"; 
                    measureBox.appendChild(titlePlaceholder);
                }

                const findSplitIndex = (text, maxHeight, isContinued) => {
                    const tempP = document.createElement('p');
                    tempP.style.lineHeight = "1.8";
                    tempP.style.marginBottom = "0";
                    tempP.style.fontFamily = FONT_MAP[fontKey].family;
                    
                    if (isContinued) tempP.classList.add('continued');
                    else tempP.style.textIndent = '1em';
                    
                    measureBox.appendChild(tempP);
                    
                    let low = 0;
                    let high = text.length;
                    let bestIdx = 0;

                    while (low <= high) {
                        const mid = Math.floor((low + high) / 2);
                        const subText = text.substring(0, mid);
                        tempP.textContent = subText;
                        
                        if (tempP.offsetHeight <= maxHeight) {
                            bestIdx = mid;
                            low = mid + 1;
                        } else {
                            high = mid - 1;
                        }
                    }
                    
                    measureBox.removeChild(tempP);
                    return bestIdx;
                };

                while (queue.length > 0) {
                    const item = queue.shift();
                    const effectiveText = (!item.isSceneBreak && item.text.trim().length === 0) ? '\u00A0' : item.text;

                    const p = document.createElement('p');
                    p.textContent = effectiveText;
                    p.style.lineHeight = "1.8";
                    p.style.marginBottom = "0";
                    p.style.fontFamily = FONT_MAP[fontKey].family;
                    
                    if (item.isSceneBreak) {
                        p.style.textAlign = 'center';
                        p.style.textIndent = '0';
                    } else if (item.isContinued) {
                        p.classList.add('continued');
                    } else {
                        p.style.textIndent = '1em';
                    }

                    measureBox.appendChild(p);
                    
                    const currentHeight = measureBox.scrollHeight;
                    const currentBuffer = (pageNum === 1) ? BOTTOM_BUFFER_P1 : 0;
                    const limitHeight = PAGE_CONTENT_HEIGHT - currentBuffer;

                    if (currentHeight <= limitHeight) {
                        currentParagraphs.push({
                            text: effectiveText,
                            isContinued: item.isContinued,
                            isSceneBreak: item.isSceneBreak
                        });
                    } 
                    else {
                        measureBox.removeChild(p); 
                        
                        const currentBaseHeight = measureBox.scrollHeight;
                        const availableHeight = limitHeight - currentBaseHeight;

                        if (availableHeight < 18) {
                            queue.unshift(item);
                        } else {
                            const splitIdx = findSplitIndex(effectiveText, availableHeight, item.isContinued);
                            
                            if (splitIdx > 0) {
                                const partA = effectiveText.substring(0, splitIdx);
                                const partB = effectiveText.substring(splitIdx);

                                currentParagraphs.push({
                                    text: partA,
                                    isContinued: item.isContinued,
                                    isSceneBreak: item.isSceneBreak
                                });

                                if (partB.length > 0) {
                                    queue.unshift({
                                        text: partB,
                                        isContinued: true,
                                        isSceneBreak: item.isSceneBreak
                                    });
                                }
                            } else {
                                queue.unshift(item);
                            }
                        }

                        resultPages.push({ paragraphs: currentParagraphs });
                        currentParagraphs = [];
                        
                        pageNum++;
                        measureBox.innerHTML = '';
                    }
                }

                if (currentParagraphs.length > 0) {
                    resultPages.push({ paragraphs: currentParagraphs });
                }

                return resultPages;
            };

            useEffect(() => {
                if (step === 'input' && debouncedText) {
                    const p = calculatePages(debouncedText, activeFont);
                    setEstimatedPages(p.length);
                } else {
                    setEstimatedPages(0);
                }
            }, [debouncedText, step, activeFont, metadata.title]);

            const startGeneration = async (targetFont = null) => {
                const fontToUse = targetFont || activeFont;
                const txt = textInput;

                if (!txt.trim()) {
                    if(!targetFont) alert("본문 내용을 입력해주세요.");
                    return;
                }

                if (document.activeElement instanceof HTMLElement) {
                    document.activeElement.blur();
                }

                setIsGenerating(true);
                
                setTimeout(() => {
                    const resultPages = calculatePages(txt, fontToUse);
                    setPages(resultPages);
                    
                    if (targetFont) {
                        setCurrentPageIdx(prev => Math.min(prev, resultPages.length - 1));
                        setActiveTab('style');
                    } else {
                        setCurrentPageIdx(0);
                        setPageHighlights({});
                        setActiveTab('style'); 
                    }
                    
                    setStep('preview');
                    setIsGenerating(false);
                    
                    if (!targetFont) {
                        setTimeout(() => window.scrollTo(0, 0), 100);
                    }
                }, 400);
            };

            const handleFontChange = (newFont) => {
                if (activeFont === newFont) return;
                
                if (window.confirm("폰트를 변경하면 페이지 레이아웃이 다시 계산됩니다.\n형광펜 및 수정 내용이 초기화됩니다. 계속하시겠습니까?")) {
                    setActiveFont(newFont);
                    setPageHighlights({});
                    startGeneration(newFont);
                }
            };

            const saveCurrentPageState = () => {
                if (contentRef.current && viewerRef.current) {
                     setPageHighlights(prev => ({
                         ...prev,
                         [currentPageIdx]: viewerRef.current.innerHTML
                     }));
                }
            };

            const handleHighlightSelection = () => {
                if (activeTab !== 'tool') return;

                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0 || selection.toString().trim() === '') return;

                const range = selection.getRangeAt(0);
                const container = contentRef.current;
                if (!container || !container.contains(range.commonAncestorContainer)) return;

                const highlightId = 'hl-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

                try {
                    const treeWalker = document.createTreeWalker(
                        range.commonAncestorContainer,
                        NodeFilter.SHOW_TEXT,
                        {
                            acceptNode: function(node) {
                                if (!range.intersectsNode(node)) return NodeFilter.FILTER_REJECT;
                                return NodeFilter.FILTER_ACCEPT;
                            }
                        }
                    );

                    const nodesToHighlight = [];
                    if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
                         if (range.intersectsNode(range.commonAncestorContainer)) {
                             nodesToHighlight.push(range.commonAncestorContainer);
                         }
                    } else {
                        let currentNode = treeWalker.nextNode();
                        while (currentNode) {
                            nodesToHighlight.push(currentNode);
                            currentNode = treeWalker.nextNode();
                        }
                    }

                    nodesToHighlight.forEach(node => {
                        const nodeRange = document.createRange();
                        nodeRange.selectNodeContents(node);

                        if (node === range.startContainer) nodeRange.setStart(node, range.startOffset);
                        if (node === range.endContainer) nodeRange.setEnd(node, range.endOffset);

                        const text = nodeRange.toString();
                        if (text.trim().length > 0) {
                            const span = document.createElement('span');
                            if (toolMode === 'highlight') {
                                span.className = `highlight ${currentHighlightColor}`;
                            } else {
                                span.className = `colored-text ${currentTextColor}`;
                            }
                            span.setAttribute('data-group-id', highlightId);
                            nodeRange.surroundContents(span);
                        }
                    });

                    selection.removeAllRanges();
                    saveCurrentPageState();
                } catch (e) {
                    console.log("Highlight failed", e);
                }
            };

            const handleContentClick = (e) => {
                if (activeTab !== 'tool') return;
                
                const target = e.target;
                let shouldRemove = false;
                
                if (toolMode === 'highlight' && target.classList.contains('highlight')) {
                    shouldRemove = true;
                } else if (toolMode === 'text' && target.classList.contains('colored-text')) {
                    shouldRemove = true;
                }

                if (shouldRemove) {
                    const groupId = target.getAttribute('data-group-id');
                    if (groupId) {
                        const allSpans = contentRef.current.querySelectorAll(`span[data-group-id="${groupId}"]`);
                        allSpans.forEach(span => {
                            const text = span.textContent;
                            const textNode = document.createTextNode(text);
                            span.parentNode.replaceChild(textNode, span);
                        });
                        saveCurrentPageState();
                    }
                }
            };

            const goToPage = (idx) => {
                saveCurrentPageState();
                setCurrentPageIdx(idx);
                window.scrollTo(0, 0);
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (step === 'preview') {
                        if (e.key === 'ArrowLeft') {
                            if (currentPageIdx > 0) goToPage(currentPageIdx - 1);
                        } else if (e.key === 'ArrowRight') {
                            if (currentPageIdx < pages.length - 1) goToPage(currentPageIdx + 1);
                        }
                    } else if (step === 'mockup') {
                         if (e.key === 'ArrowLeft') {
                            setCurrentMockupIdx(prev => Math.max(0, prev - 1));
                        } else if (e.key === 'ArrowRight') {
                            setCurrentMockupIdx(prev => Math.min(mockupSpreads.length - 1, prev + 1));
                        }
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [step, currentPageIdx, pages.length, mockupSpreads.length]);

            const touchStartRef = useRef(null);
            const touchEndRef = useRef(null);
            const minSwipeDistance = 50;

            const onTouchStart = (e) => {
                touchEndRef.current = null; 
                touchStartRef.current = e.targetTouches[0].clientX;
            };
            const onTouchMove = (e) => {
                touchEndRef.current = e.targetTouches[0].clientX;
            };
            const onTouchEnd = () => {
                if (activeTab === 'tool' || isEditingInfo) return;
                
                if (!touchStartRef.current || !touchEndRef.current) return;
                const distance = touchStartRef.current - touchEndRef.current;
                const isLeftSwipe = distance > minSwipeDistance;
                const isRightSwipe = distance < -minSwipeDistance;

                if (step === 'preview') {
                    if (isLeftSwipe && currentPageIdx < pages.length - 1) {
                        goToPage(currentPageIdx + 1);
                    }
                    if (isRightSwipe && currentPageIdx > 0) {
                        goToPage(currentPageIdx - 1);
                    }
                } else if (step === 'mockup') {
                    if (isLeftSwipe && currentMockupIdx < mockupSpreads.length - 1) {
                         setCurrentMockupIdx(prev => Math.min(mockupSpreads.length - 1, prev + 1));
                    }
                    if (isRightSwipe && currentMockupIdx > 0) {
                        setCurrentMockupIdx(prev => Math.max(0, prev - 1));
                    }
                }
            };

            const backToEdit = () => {
                if (window.confirm('형광펜이 모두 지워집니다. 수정 화면으로 가시겠습니까?')) {
                    setStep('input');
                    setPages([]);
                    setPageHighlights({});
                    setCurrentPageIdx(0);
                    setActiveTab(null);
                    window.scrollTo(0, 0);
                }
            };

            const resetApp = () => {
                if (window.confirm('작업 내용을 지우고 처음으로 돌아가시겠습니까?')) {
                    setStep('input');
                    setPages([]);
                    setPageHighlights({});
                    setTextInput('');
                    setMetadata({ ...metadata, title: '', author: '', producer: '' });
                    setActiveTab(null);
                    window.scrollTo(0, 0);
                }
            };

            const openMockup = () => {
                saveCurrentPageState();
                const spreads = [];
                spreads.push({ type: 'cover', leftPageIdx: null, rightPageIdx: 0 });
                for (let i = 1; i < pages.length; i += 2) {
                    spreads.push({
                        type: 'spread',
                        leftPageIdx: i,
                        rightPageIdx: (i + 1 < pages.length) ? i + 1 : null
                    });
                }
                setMockupSpreads(spreads);
                
                let initialSpread = 0;
                if (currentPageIdx === 0) {
                    initialSpread = 0;
                } else {
                    initialSpread = Math.ceil(currentPageIdx / 2);
                }
                setCurrentMockupIdx(initialSpread);
                setStep('mockup');
            };

            const downloadMockup = async () => {
                const target = document.getElementById('mockupTarget');
                if (!target) return;

                setLoadingMessage('목업 제작 준비 중...');
                await new Promise(resolve => setTimeout(resolve, 50));
                
                try {
                    await ensureFontsLoaded();
                    const fontEmbedCSS = await prepareFontEmbedCSS(activeFont);

                    if (isIOS() || isIPad()) {
                        setLoadingMessage('리소스 로딩 중...');
                        try {
                            await htmlToImage.toBlob(target, {
                                width: 1,
                                height: 1,
                                pixelRatio: 1,
                                skipFonts: true 
                            });
                        } catch(e) {
                            console.debug('Warmup partial fail', e);
                        }
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                    setLoadingMessage('고화질 렌더링 적용 중...');
                    await new Promise(resolve => setTimeout(resolve, 800));

                    setLoadingMessage('이미지 변환 중...');
                    await new Promise(resolve => setTimeout(resolve, 10));

                    const options = {
                        quality: 1.0,
                        pixelRatio: 2, 
                        cacheBust: false,
                        backgroundColor: '#f2efe9',
                        width: target.scrollWidth,
                        height: target.scrollHeight,
                        style: {
                            transform: 'none',
                            margin: '0'
                        },
                        filter: (node) => {
                            if (node.id === 'mockup-info-area' && !infoText.trim()) return false;
                            return true;
                        }
                    };
                    if (fontEmbedCSS) options.fontEmbedCSS = fontEmbedCSS;
                    
                    const blob = await htmlToImage.toBlob(target, options);

                    setLoadingMessage('파일 저장 중...');

                    if (blob) {
                        const fileName = `${metadata.title || 'novel'}_mockup_${currentMockupIdx + 1}.png`;
                        
                        if (isIOS() && navigator.share && navigator.canShare) {
                             const file = new File([blob], fileName, { type: 'image/png' });
                             if (navigator.canShare({ files: [file] })) {
                                try {
                                    await navigator.share({ files: [file], title: fileName });
                                } catch (e) {
                                    if (e.name !== 'AbortError') downloadBlobFallback(blob, fileName);
                                }
                             } else {
                                 downloadBlobFallback(blob, fileName);
                             }
                        } else {
                            downloadBlobFallback(blob, fileName);
                        }
                    }
                } catch (e) {
                    console.error('Mockup download failed:', e);
                    alert('목업 저장에 실패했습니다.');
                } finally {
                    setLoadingMessage('');
                }
            };
            
            const downloadAllMockups = async () => {
                if (isMobile()) return; 

                if (!window.confirm(`총 ${mockupSpreads.length}장의 목업 이미지를 저장합니다.\n시간이 다소 걸릴 수 있습니다.`)) return;

                const originalIdx = currentMockupIdx; 

                try {
                    await ensureFontsLoaded();
                    const fontEmbedCSS = await prepareFontEmbedCSS(activeFont);

                    for (let i = 0; i < mockupSpreads.length; i++) {
                        setCurrentMockupIdx(i);
                        setLoadingMessage(`목업 제작 중... (${i + 1}/${mockupSpreads.length})`);
                        setLoadingProgress(Math.floor(((i + 1) / mockupSpreads.length) * 100));
                        
                        await new Promise(resolve => setTimeout(resolve, 800));

                        const target = document.getElementById('mockupTarget');
                        if (target) {
                             const options = {
                                quality: 1.0,
                                pixelRatio: 2,
                                cacheBust: false,
                                backgroundColor: '#f2efe9',
                                width: target.scrollWidth,
                                height: target.scrollHeight,
                                style: {
                                    transform: 'none',
                                    margin: '0'
                                },
                                filter: (node) => {
                                    if (node.id === 'mockup-info-area' && !infoText.trim()) return false;
                                    return true;
                                }
                            };
                            if (fontEmbedCSS) options.fontEmbedCSS = fontEmbedCSS;

                            const blob = await htmlToImage.toBlob(target, options);
                            if (blob) {
                                 const fileName = `${metadata.title || 'novel'}_mockup_${String(i+1).padStart(3, '0')}.png`;
                                 downloadBlobFallback(blob, fileName);
                            }
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    alert("모든 목업 이미지가 저장되었습니다.");
                } catch (e) {
                    console.error(e);
                    alert("오류가 발생했습니다.");
                } finally {
                    setLoadingMessage('');
                    setLoadingProgress(0);
                    setCurrentMockupIdx(originalIdx); 
                }
            };

            const downloadBlobFallback = (blob, fileName) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = fileName;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            };

            const downloadCurrentPage = async () => {
                const target = document.getElementById('captureTarget');
                if (!target) return;

                const title = metadata.title || 'novel';
                const fileName = `${title}_${currentPageIdx + 1}p.png`;

                setLoadingMessage('폰트 로딩 중...');
                
                try {
                    await ensureFontsLoaded();

                    if (isIOS()) {
                        setLoadingMessage('렌더링 준비 중...');
                        await new Promise(resolve => setTimeout(resolve, 800)); 
                    }
                    
                    const fontEmbedCSS = await prepareFontEmbedCSS(activeFont);

                    setLoadingMessage('이미지 생성 중...');
                    await new Promise(resolve => setTimeout(resolve, isIOS() ? 1000 : 500));

                    if (target) { const _ = target.offsetHeight; }
                    
                    const options = {
                        quality: 1.0,
                        pixelRatio: 3,
                        cacheBust: false,
                        backgroundColor: null,
                        preferredFontFormat: 'woff2',
                        skipFonts: true, 
                        width: 420,
                        height: 600,
                        style: {
                            fontFamily: FONT_MAP[activeFont].family,
                            margin: '0',
                            transform: 'none'
                        }
                    };
                    if (fontEmbedCSS) options.fontEmbedCSS = fontEmbedCSS;

                    if (isIPad()) {
                        try {
                            await htmlToImage.toBlob(target, options);
                        } catch (e) {
                            console.debug('Warm-up shot failed', e);
                        }
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }

                    const blob = await htmlToImage.toBlob(target, options);
                    if (!blob) throw new Error('Blob creation failed');

                    if (isIOS() && navigator.share && navigator.canShare) {
                        const file = new File([blob], fileName, { type: 'image/png' });
                        if (navigator.canShare({ files: [file] })) {
                            try {
                                await navigator.share({ files: [file], title: fileName });
                            } catch (shareError) {
                                if (shareError.name !== 'AbortError') {
                                    downloadBlobFallback(blob, fileName);
                                }
                            }
                        } else {
                            downloadBlobFallback(blob, fileName);
                        }
                    } else {
                        downloadBlobFallback(blob, fileName);
                    }

                } catch (error) {
                    console.error('[다운로드] 실패:', error);
                    alert('이미지 생성에 실패했습니다. 다시 시도해주세요.');
                } finally {
                    setLoadingMessage('');
                }
            };

            const downloadAllPages = async () => {
                if (isMobile()) return; 

                if (!window.confirm(`총 ${pages.length}장의 이미지를 저장합니다.`)) return;

                saveCurrentPageState();
                const originalPageIdx = currentPageIdx;
                window.scrollTo(0, 0);
                
                try {
                    await ensureFontsLoaded();
                    const fontEmbedCSS = await prepareFontEmbedCSS(activeFont);

                    for (let i = 0; i < pages.length; i++) {
                        setCurrentPageIdx(i);
                        setLoadingMessage(`저장 중... (${i + 1}/${pages.length})`);
                        setLoadingProgress(Math.floor(((i + 1) / pages.length) * 100));
                        
                        await new Promise(resolve => setTimeout(resolve, 500));

                        const target = document.getElementById('captureTarget');
                        if (target) { const _ = target.offsetHeight; }

                        if (target) {
                            const options = {
                                quality: 1.0,
                                pixelRatio: 3,
                                cacheBust: false,
                                skipFonts: true,
                                width: 420,
                                height: 600,
                                style: {
                                    fontFamily: FONT_MAP[activeFont].family,
                                    margin: '0',
                                    transform: 'none'
                                }
                            };
                            if (fontEmbedCSS) options.fontEmbedCSS = fontEmbedCSS;

                            const blob = await htmlToImage.toBlob(target, options);
                            if (blob) {
                                 const fileName = `${metadata.title || 'novel'}_${String(i+1).padStart(3, '0')}p.png`;
                                 downloadBlobFallback(blob, fileName);
                            }
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }
                    alert("완료되었습니다.");
                } catch (e) {
                    console.error(e);
                    alert("오류가 발생했습니다.");
                } finally {
                    setLoadingMessage('');
                    setLoadingProgress(0);
                    setCurrentPageIdx(originalPageIdx);
                }
            };

            return (
                <div className="min-h-screen font-serif" onTouchStart={onTouchStart} onTouchMove={onTouchMove} onTouchEnd={onTouchEnd}>
                    <div ref={measureContainerRef} className="hidden-measure"></div>

                    {loadingMessage && (
                        <div className="fixed inset-0 bg-black/70 text-white flex flex-col items-center justify-center z-[10000]">
                            <div className="text-xl mb-4 font-light">{loadingMessage}</div>
                            {loadingProgress > 0 && (
                                <div className="text-sm opacity-80">잠시만 기다려주세요 ({loadingProgress}%)</div>
                            )}
                        </div>
                    )}
                    
                    {isEditingInfo && <div className="fixed inset-0 bg-black/50 z-[9999] transition-opacity duration-300"></div>}

                    {step === 'input' && (
                        <div className="max-w-[900px] mx-auto my-10 bg-white p-6 md:p-10 rounded-2xl shadow-sm">
                            <div className="flex flex-col md:flex-row md:items-center justify-between mb-8 border-b pb-4 gap-4">
                                <div className="flex items-center gap-3">
                                    <h1 className="text-2xl font-serif font-medium text-slate-800">소설 내지 생성기</h1>
                                    <span className="text-xs bg-indigo-100 text-indigo-800 px-2 py-1 rounded font-bold">v1.2.0</span>
                                </div>
                                <a href="https://yuliyulidaz.github.io/yulilog/" target="_blank" rel="noreferrer" className="flex items-center gap-1.5 text-slate-400 hover:text-indigo-600 transition-colors py-1 px-2 rounded hover:bg-indigo-50 w-fit">
                                    <span className="text-lg">🔗</span>
                                    <span className="text-xs font-medium">발췌 문구 생성기 바로가기</span>
                                </a>
                            </div>

                            <div className="mb-6">
                                <label className="block text-sm text-slate-500 mb-1">제목 (필요시 입력)</label>
                                <input 
                                    type="text" 
                                    value={metadata.title}
                                    onChange={(e) => setMetadata({...metadata, title: e.target.value})}
                                    className="w-full p-3 border rounded-lg bg-slate-50 focus:bg-white focus:ring-2 ring-slate-200 outline-none transition-all" 
                                    placeholder="제목을 입력하세요" 
                                />
                            </div>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                                <div>
                                    <label className="block text-sm text-slate-500 mb-1">캐릭터</label>
                                    <input 
                                        type="text" 
                                        value={metadata.author}
                                        onChange={(e) => setMetadata({...metadata, author: e.target.value})}
                                        className="w-full p-3 border rounded-lg bg-slate-50 focus:bg-white focus:ring-2 ring-slate-200 outline-none transition-all" 
                                    />
                                </div>
                                <div>
                                    <label className="block text-sm text-slate-500 mb-1">제작자</label>
                                    <input 
                                        type="text" 
                                        value={metadata.producer}
                                        onChange={(e) => setMetadata({...metadata, producer: e.target.value})}
                                        className="w-full p-3 border rounded-lg bg-slate-50 focus:bg-white focus:ring-2 ring-slate-200 outline-none transition-all" 
                                    />
                                </div>
                            </div>

                            <div className="mb-6 relative">
                                <label className="block text-sm text-slate-500 mb-1 flex justify-between">
                                    <span>본문 내용</span>
                                    {estimatedPages > 0 && (
                                        <span className="text-indigo-600 font-bold">예상 분량: 약 {estimatedPages} 페이지</span>
                                    )}
                                </label>
                                <div className="relative">
                                    {!textInput && (
                                        <div className="custom-placeholder">
                                            <p className="mb-4">여기에 소설 본문을 붙여넣으세요.<br/>엔터로 줄바꿈을 하면 빈 줄이 적용됩니다.<br/>*** 를 입력하면 장면 전환(중앙 정렬)이 적용됩니다.</p>
                                            
                                            <div className="mt-6 border-t border-slate-100 pt-4">
                                                <strong className="block mb-2 text-indigo-400 text-xs">📢 2024.11.20 업데이트 안내 (v1.2.0)</strong>
                                                <ul className="list-disc pl-4 space-y-1 text-[11px] text-slate-400">
                                                    <li><strong>목업(Mockup) 모드:</strong> 내지를 실제 책 느낌의 3D 이미지로 미리보고 저장할 수 있습니다.</li>
                                                    <li><strong>글자색 도구:</strong> 형광펜 외에 본문 글자 색상(잉크) 변경 기능이 추가되었습니다.</li>
                                                    <li><strong>PC/모바일 최적화:</strong> 모바일 펼침면 보기 및 PC 목업 일괄 저장 기능을 지원합니다.</li>
                                                    <li><strong>기본 기능:</strong> 4가지 테마/폰트, 형광펜, 페이지 넘김 기능 등 기존 기능 유지.</li>
                                                </ul>
                                            </div>
                                        </div>
                                    )}
                                    <textarea 
                                        value={textInput}
                                        onChange={(e) => setTextInput(e.target.value)}
                                        className="w-full h-[400px] p-6 border rounded-lg bg-slate-50 focus:bg-white focus:ring-2 ring-slate-200 outline-none transition-all resize-none font-serif leading-loose relative z-10 bg-transparent" 
                                    ></textarea>
                                </div>
                            </div>

                            <button onClick={() => startGeneration(null)} disabled={isGenerating} className="btn w-full py-4 bg-slate-800 text-white rounded-lg font-medium hover:bg-slate-700 shadow-lg flex justify-center items-center gap-2 disabled:opacity-70">
                                <span>{isGenerating ? '생성 중...' : 'A6 레이아웃 생성하기'}</span>
                            </button>
                            
                             <footer className="max-w-4xl mx-auto px-6 py-10 text-slate-500 text-xs text-center leading-relaxed mt-12 border-t border-slate-200">
                                <p className="font-bold mb-2 text-sm text-slate-700">📖 소설 내지 생성기 v1.2.0</p>
                                <p className="mb-6">본 사이트는 어떠한 개인정보도 수집하지 않습니다.<br/>모든 작업은 귀하의 브라우저에서만 이루어집니다.</p>
                                
                                <div className="bg-slate-50 rounded-xl p-6 text-left inline-block w-full max-w-2xl border border-slate-100">
                                    <p className="font-bold mb-3 text-slate-700 flex items-center gap-2">
                                        <span className="text-base">⚠️</span> 이용 시 주의사항
                                    </p>
                                    <ul className="list-disc pl-4 space-y-2 mb-5 text-slate-600">
                                        <li><strong className="text-slate-700">텍스트 인용:</strong> 책이나 기타 저작물의 텍스트를 발췌할 경우, 저작권법상 허용 범위 내에서 사용하고 출처를 명시하세요.</li>
                                        <li><strong className="text-slate-700">상업적 이용:</strong> 생성된 이미지는 상업적으로 사용할 수 없습니다.</li>
                                    </ul>
                                    <p className="text-slate-400 text-[11px] pt-4 border-t border-slate-200">
                                        본 도구의 제작자는 사용자가 생성한 콘텐츠에 대해 어떠한 책임도 지지 않습니다.<br/>
                                        이미지 및 텍스트 사용으로 인해 발생하는 모든 법적 문제는 사용자 본인의 책임입니다.
                                    </p>
                                </div>
                            </footer>
                        </div>
                    )}

                    {step === 'preview' && (
                        <div className="pb-32 bg-gray-100 min-h-screen">
                            <div className="sticky top-0 z-50 bg-white shadow-sm">
                                <div className="flex items-center justify-between px-4 py-3 border-b border-slate-100 max-w-2xl mx-auto w-full">
                                    <div className="flex items-center gap-4">
                                        <button onClick={resetApp} className="flex flex-col items-center justify-center w-10 text-slate-500 hover:text-red-600 transition-colors">
                                            <span className="text-xl leading-none">↺</span>
                                            <span className="text-[9px] mt-0.5">초기화</span>
                                        </button>
                                        <button onClick={backToEdit} className="flex flex-col items-center justify-center w-10 text-slate-500 hover:text-indigo-600 transition-colors">
                                            <span className="text-xl leading-none">✎</span>
                                            <span className="text-[9px] mt-0.5">수정</span>
                                        </button>
                                    </div>

                                    <div className="flex items-center gap-3 bg-slate-50 px-3 py-1.5 rounded-full border border-slate-200">
                                        <button onClick={() => { if(currentPageIdx > 0) goToPage(currentPageIdx - 1) }} disabled={currentPageIdx === 0} className="text-slate-400 hover:text-slate-800 disabled:opacity-20 px-1">‹</button>
                                        <span className="font-serif tabular-nums text-sm w-12 text-center text-slate-700">{currentPageIdx + 1} / {pages.length}</span>
                                        <button onClick={() => { if(currentPageIdx < pages.length - 1) goToPage(currentPageIdx + 1) }} disabled={currentPageIdx === pages.length - 1} className="text-slate-400 hover:text-slate-800 disabled:opacity-20 px-1">›</button>
                                    </div>

                                    <div className="flex items-center gap-2">
                                        <button onClick={openMockup} className="bg-indigo-100 text-indigo-700 px-3 py-2 rounded-lg text-xs font-bold hover:bg-indigo-200 flex items-center gap-1.5 transition-colors">
                                            <span>📚</span>
                                            <span>목업</span>
                                        </button>

                                        {!isMobile() && (
                                            <button onClick={downloadAllPages} className="bg-slate-100 text-slate-600 px-3 py-2 rounded-lg text-xs font-medium hover:bg-slate-200 transition-colors">
                                                전체 저장
                                            </button>
                                        )}

                                        <button onClick={downloadCurrentPage} className="bg-slate-800 text-white px-3 py-2 rounded-lg text-xs font-medium hover:bg-slate-700 shadow-sm flex items-center gap-1.5">
                                            <span className="text-sm">{isIOS() ? '📥' : '📥'}</span>
                                            <span>{isIOS() ? '저장' : '저장'}</span>
                                        </button>
                                    </div>
                                </div>

                                <div className="flex border-b border-slate-200 max-w-2xl mx-auto w-full">
                                    <button 
                                        onClick={() => setActiveTab(activeTab === 'style' ? null : 'style')}
                                        className={`flex-1 py-3 text-xs font-medium flex items-center justify-center gap-2 transition-all ${activeTab === 'style' ? 'text-indigo-600 border-b-2 border-indigo-600 bg-indigo-50/30' : 'text-slate-500 hover:bg-slate-50'}`}
                                    >
                                        <span>🎨 스타일 설정</span>
                                    </button>
                                    <button 
                                        onClick={() => setActiveTab(activeTab === 'tool' ? null : 'tool')}
                                        className={`flex-1 py-3 text-xs font-medium flex items-center justify-center gap-2 transition-all ${activeTab === 'tool' ? 'text-pink-600 border-b-2 border-pink-600 bg-pink-50/30' : 'text-slate-500 hover:bg-slate-50'}`}
                                    >
                                        <span>🛠 도구</span>
                                    </button>
                                </div>

                                {activeTab && (
                                    <div className="bg-slate-50/80 backdrop-blur-sm border-b border-slate-200 animate-fade-in">
                                        <div className="max-w-2xl mx-auto w-full p-4">
                                            
                                            {activeTab === 'style' && (
                                                <div className="flex flex-col gap-5 animate-slide-down">
                                                    <div className="flex items-center justify-center gap-4">
                                                        <span className="text-[10px] tracking-widest text-slate-400 font-bold">THEME</span>
                                                        <div className="flex gap-3">
                                                            {['white', 'cream', 'kraft', 'dark'].map(theme => (
                                                                <button
                                                                    key={theme}
                                                                    onClick={() => setActiveTheme(theme)}
                                                                    className={`circle-btn theme-btn-${theme} ${activeTheme === theme ? 'active shadow-md' : ''}`}
                                                                    title={theme}
                                                                ></button>
                                                            ))}
                                                        </div>
                                                    </div>
                                                    <div className="h-px bg-slate-200 w-full"></div>
                                                    <div className="flex flex-col items-center gap-2">
                                                        <div className="flex items-center gap-4">
                                                            <span className="text-[10px] tracking-widest text-slate-400 font-bold">FONT</span>
                                                            <div className="flex gap-1 bg-white p-1 rounded-lg border border-slate-200">
                                                                {Object.keys(FONT_MAP).map(key => (
                                                                    <button
                                                                        key={key}
                                                                        onClick={() => handleFontChange(key)}
                                                                        className={`px-3 py-1.5 text-xs rounded-md transition-all ${activeFont === key ? 'bg-slate-800 text-white shadow-sm' : 'text-slate-500 hover:bg-slate-100'}`}
                                                                    >
                                                                        {FONT_MAP[key].name}
                                                                    </button>
                                                                ))}
                                                            </div>
                                                        </div>
                                                        <p className="text-[10px] text-red-400 mt-1">⚠ 폰트 변경 시 형광펜이 초기화됩니다.</p>
                                                    </div>
                                                </div>
                                            )}

                                            {activeTab === 'tool' && (
                                                <div className="flex flex-col items-center gap-3 animate-slide-down">
                                                    <div className="flex bg-slate-200 rounded-lg p-1 mb-1">
                                                       <button onClick={() => setToolMode('highlight')} className={`px-3 py-1 text-xs rounded-md transition-all ${toolMode === 'highlight' ? 'bg-white shadow-sm text-slate-800 font-medium' : 'text-slate-500'}`}>🖍 형광펜</button>
                                                       <button onClick={() => setToolMode('text')} className={`px-3 py-1 text-xs rounded-md transition-all ${toolMode === 'text' ? 'bg-white shadow-sm text-slate-800 font-medium' : 'text-slate-500'}`}>✒️ 글자색</button>
                                                    </div>

                                                    <p className="text-[10px] text-slate-500">💡 Tip: 폰트를 먼저 확정한 후 도구를 사용하세요.</p>
                                                    
                                                    {toolMode === 'highlight' ? (
                                                        <div className="flex gap-4">
                                                            {['highlight-yellow', 'highlight-pink', 'highlight-mint', 'highlight-blue'].map(color => (
                                                                <button 
                                                                    key={color} 
                                                                    onClick={() => setCurrentHighlightColor(color)}
                                                                    className={`circle-btn ${color} ${currentHighlightColor === color ? 'border-slate-800 scale-110 shadow-sm' : ''}`}
                                                                ></button>
                                                            ))}
                                                        </div>
                                                    ) : (
                                                        <div className="flex gap-4">
                                                            {[
                                                                { id: 'text-crimson', bg: 'bg-text-crimson' },
                                                                { id: 'text-navy', bg: 'bg-text-navy' },
                                                                { id: 'text-forest', bg: 'bg-text-forest' },
                                                                { id: 'text-purple', bg: 'bg-text-purple' },
                                                                { id: 'text-brown', bg: 'bg-text-brown' },
                                                                { id: 'text-teal', bg: 'bg-text-teal' },
                                                                { id: 'text-gray', bg: 'bg-text-gray' }
                                                            ].map(item => (
                                                                <button 
                                                                    key={item.id} 
                                                                    onClick={() => setCurrentTextColor(item.id)}
                                                                    className={`circle-btn ${item.bg} ${currentTextColor === item.id ? 'border-slate-800 scale-110 shadow-sm' : ''}`}
                                                                ></button>
                                                            ))}
                                                        </div>
                                                    )}
                                                    
                                                    <p className="text-[10px] text-slate-400">드래그하여 적용, 터치하여 삭제</p>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>

                            <div id="bookViewerWrapper" className="flex justify-center overflow-visible px-4 py-8 select-text cursor-text" onClick={() => {}}>
                                <div 
                                    ref={viewerRef}
                                    id="captureTarget" 
                                    className={`page-container theme-${activeTheme}`}
                                    style={{ fontFamily: FONT_MAP[activeFont].family }} 
                                >
                                    {pageHighlights[currentPageIdx] ? (
                                        <div 
                                            ref={contentRef}
                                            onMouseUp={handleHighlightSelection}
                                            onTouchEnd={handleHighlightSelection}
                                            onClick={handleContentClick}
                                            dangerouslySetInnerHTML={{ __html: pageHighlights[currentPageIdx] }}
                                            style={{display: 'contents'}}
                                        />
                                    ) : (
                                        <>
                                            <div ref={contentRef} className="page-content" onMouseUp={handleHighlightSelection} onTouchEnd={handleHighlightSelection} onClick={handleContentClick}>
                                                {currentPageIdx === 0 && metadata.title && (
                                                    <div style={{height: '200px', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', marginBottom: 0}}>
                                                        <h1 className="text-base tracking-[0.1em] font-normal text-center px-4" style={{lineHeight: 1.8, maxHeight: '70px', overflow: 'hidden', opacity: 0.8}}>
                                                            {metadata.title}
                                                        </h1>
                                                        <div className="w-8 h-[1px] bg-current opacity-30 mx-auto mt-14"></div>
                                                    </div>
                                                )}

                                                {pages[currentPageIdx]?.paragraphs.map((p, i) => (
                                                    <p key={i} 
                                                        className={p.isContinued ? 'continued' : ''} 
                                                        style={{
                                                            lineHeight: 1.8,
                                                            textAlign: p.isSceneBreak ? 'center' : undefined,
                                                            textIndent: p.isSceneBreak ? '0' : undefined
                                                        }}
                                                    >
                                                        {p.text}
                                                    </p>
                                                ))}
                                            </div>

                                            <div className={`page-footer-area text-[9px] opacity-50 ${(currentPageIdx + 1) % 2 !== 0 ? 'justify-end' : 'justify-start'}`}>
                                                <div className={`flex items-center gap-2 ${(currentPageIdx + 1) % 2 !== 0 ? 'flex-row' : 'flex-row-reverse'}`}>
                                                    {(metadata.producer || metadata.author) && (
                                                        <span>{[metadata.producer, metadata.author].filter(Boolean).join(' · ')}</span>
                                                    )}
                                                    <span className="font-normal opacity-70">{currentPageIdx + 1}</span>
                                                </div>
                                            </div>
                                        </>
                                    )}
                                </div>
                            </div>
                            
                            <div className="fixed bottom-8 left-0 right-0 px-6 z-40 flex justify-between pointer-events-none">
                                <button 
                                    onClick={() => { if(currentPageIdx > 0) goToPage(currentPageIdx - 1) }} 
                                    disabled={currentPageIdx === 0}
                                    className="pointer-events-auto w-[45px] h-[45px] rounded-full bg-white/60 backdrop-blur-sm shadow-lg border border-slate-200/10 flex items-center justify-center text-slate-600 hover:text-indigo-600 hover:scale-105 active:scale-95 transition-all disabled:opacity-0 disabled:translate-y-4"
                                    aria-label="이전 페이지"
                                >
                                    <span className="text-2xl leading-none pb-1 pr-0.5">‹</span>
                                </button>

                                <button 
                                    onClick={() => { if(currentPageIdx < pages.length - 1) goToPage(currentPageIdx + 1) }} 
                                    disabled={currentPageIdx === pages.length - 1}
                                    className="pointer-events-auto w-[45px] h-[45px] rounded-full bg-white/60 backdrop-blur-sm shadow-lg border border-slate-200/10 flex items-center justify-center text-slate-600 hover:text-indigo-600 hover:scale-105 active:scale-95 transition-all disabled:opacity-0 disabled:translate-y-4"
                                    aria-label="다음 페이지"
                                >
                                    <span className="text-2xl leading-none pb-1 pl-0.5">›</span>
                                </button>
                            </div>
                        </div>
                    )}

                    {step === 'mockup' && (
                        <div className="mockup-bg">
                            <div className="fixed top-0 left-0 right-0 p-4 flex justify-between items-center z-50 pointer-events-none">
                                <button 
                                    onClick={() => setStep('preview')}
                                    className="pointer-events-auto bg-white/80 backdrop-blur-md text-slate-700 px-4 py-2 rounded-full text-xs font-bold shadow-sm hover:bg-white flex items-center gap-2"
                                >
                                    <span>✕ 닫기</span>
                                </button>
                                
                                <div className="pointer-events-auto flex gap-2">
                                     <button 
                                        onClick={() => setCurrentMockupIdx(prev => Math.max(0, prev - 1))}
                                        disabled={currentMockupIdx === 0}
                                        className="bg-white/80 backdrop-blur-md w-10 h-10 rounded-full flex items-center justify-center text-slate-700 shadow-sm hover:bg-white disabled:opacity-30"
                                    >
                                        ‹
                                    </button>
                                    <button 
                                        onClick={() => setCurrentMockupIdx(prev => Math.min(mockupSpreads.length - 1, prev + 1))}
                                        disabled={currentMockupIdx === mockupSpreads.length - 1}
                                        className="bg-white/80 backdrop-blur-md w-10 h-10 rounded-full flex items-center justify-center text-slate-700 shadow-sm hover:bg-white disabled:opacity-30"
                                    >
                                        ›
                                    </button>
                                </div>

                                <div className="flex gap-2 pointer-events-auto">
                                    {!isMobile() && (
                                        <button 
                                            onClick={downloadAllMockups}
                                            className="bg-white/80 backdrop-blur-md text-slate-700 px-4 py-2 rounded-full text-xs font-bold shadow-sm hover:bg-white flex items-center gap-2"
                                        >
                                            <span>전체 저장</span>
                                        </button>
                                    )}
                                    <button 
                                        onClick={downloadMockup}
                                        className="bg-slate-800 text-white px-5 py-2 rounded-full text-xs font-bold shadow-lg hover:bg-slate-700 flex items-center gap-2"
                                    >
                                        <span>저장</span>
                                    </button>
                                </div>
                            </div>

                            <div className="book-container" id="mockupTarget">
                                <div className="book-shadow-wrapper">
                                    <div className="book-real-shadow"></div>

                                    <div className="book-spine-shadow"></div>
                                    
                                    <div className="mockup-page relative">
                                        <div className="paper-stack-left"></div>
                                        <div className="curve-left"></div>
                                        
                                        {mockupSpreads[currentMockupIdx].type === 'cover' ? (
                                            <div className="mockup-endpaper relative">
                                                <div 
                                                    id="mockup-info-area" 
                                                    className={`transition-all duration-300 ${
                                                        isEditingInfo
                                                          ? 'fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 scale-[2.8] z-[10000] w-32 p-4 rounded bg-[#2c3e50] shadow-2xl origin-center'
                                                          : 'absolute bottom-12 left-12 w-32 text-left z-20 origin-bottom-left'
                                                    }`}
                                                >
                                                    {!infoText && !isEditingInfo && (
                                                        <div className="absolute inset-0 border border-white/20 border-dashed rounded flex items-center justify-center pointer-events-none animate-pulse">
                                                            <span className="text-[10px] text-white/50 font-sans tracking-widest">+ INFO / MEMO</span>
                                                        </div>
                                                    )}
                                                    
                                                    <div className="h-px bg-white/40 w-20 mb-3"></div>
                                                    <textarea
                                                        value={infoText}
                                                        onChange={handleInfoChange}
                                                        onFocus={handleInfoFocus}
                                                        onBlur={handleInfoBlur}
                                                        placeholder=""
                                                        className="w-full h-32 bg-transparent text-white/80 text-[10px] font-sans tracking-wider leading-relaxed resize-none outline-none overflow-hidden placeholder-white/20"
                                                        spellCheck="false"
                                                    />
                                                </div>
                                            </div>
                                        ) : (
                                            <div className={`page-container theme-${activeTheme} h-full w-full`} style={{ fontFamily: FONT_MAP[activeFont].family, transform: 'none', margin: 0, boxShadow: 'none' }}>
                                                {(() => {
                                                    const idx = mockupSpreads[currentMockupIdx].leftPageIdx;
                                                    return pageHighlights[idx] ? (
                                                        <div dangerouslySetInnerHTML={{ __html: pageHighlights[idx] }} className="h-full w-full flex flex-col"/>
                                                    ) : (
                                                        <div className="page-content flex flex-col h-full w-full">
                                                            {pages[idx]?.paragraphs.map((p, i) => (
                                                                <p key={i} className={p.isContinued ? 'continued' : ''} style={{lineHeight: 1.8, textAlign: p.isSceneBreak ? 'center' : undefined, textIndent: p.isSceneBreak ? '0' : undefined}}>{p.text}</p>
                                                            ))}
                                                            <div className="page-footer-area mt-auto justify-start">
                                                                <div className="flex items-center gap-2 flex-row-reverse opacity-50 text-[9px]">
                                                                    {(metadata.producer || metadata.author) && (<span>{[metadata.producer, metadata.author].filter(Boolean).join(' · ')}</span>)}
                                                                    <span className="font-normal opacity-70">{idx + 1}</span>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    );
                                                })()}
                                            </div>
                                        )}
                                    </div>
                                    
                                    <div className="mockup-page relative">
                                        <div className="paper-stack-right"></div>
                                        <div className="curve-right"></div>
                                        
                                        {mockupSpreads[currentMockupIdx].rightPageIdx !== null ? (
                                            <div className={`page-container theme-${activeTheme} h-full w-full`} style={{ fontFamily: FONT_MAP[activeFont].family, transform: 'none', margin: 0, boxShadow: 'none' }}>
                                                {(() => {
                                                    const idx = mockupSpreads[currentMockupIdx].rightPageIdx;
                                                    return pageHighlights[idx] ? (
                                                        <div dangerouslySetInnerHTML={{ __html: pageHighlights[idx] }} className="h-full w-full flex flex-col"/>
                                                    ) : (
                                                        <div className="page-content flex flex-col h-full w-full">
                                                            {idx === 0 && metadata.title && (
                                                                <div style={{height: '200px', display: 'flex', flexDirection: 'column', justifyContent: 'center', alignItems: 'center', marginBottom: 0}}>
                                                                    <h1 className="text-base tracking-[0.1em] font-normal text-center px-4" style={{lineHeight: 1.8, maxHeight: '70px', overflow: 'hidden', opacity: 0.8}}>{metadata.title}</h1>
                                                                    <div className="w-8 h-[1px] bg-current opacity-30 mx-auto mt-14"></div>
                                                                </div>
                                                            )}
                                                            {pages[idx]?.paragraphs.map((p, i) => (
                                                                <p key={i} className={p.isContinued ? 'continued' : ''} style={{lineHeight: 1.8, textAlign: p.isSceneBreak ? 'center' : undefined, textIndent: p.isSceneBreak ? '0' : undefined}}>{p.text}</p>
                                                            ))}
                                                            <div className="page-footer-area mt-auto justify-end">
                                                                <div className="flex items-center gap-2 flex-row opacity-50 text-[9px]">
                                                                    {(metadata.producer || metadata.author) && (<span>{[metadata.producer, metadata.author].filter(Boolean).join(' · ')}</span>)}
                                                                    <span className="font-normal opacity-70">{idx + 1}</span>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    );
                                                })()}
                                            </div>
                                        ) : (
                                                <div className="h-full w-full bg-white"></div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
